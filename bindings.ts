// This file has been generated by Specta. DO NOT EDIT.

import { createTauRPCProxy as createProxy, type InferCommandOutput } from 'taurpc'
type TAURI_CHANNEL<T> = (response: T) => void


export type AppError = { type: "Io" } | { type: "Db" } | { type: "Other"; data: string }

/**
 * Column definition in a query result
 */
export type ColumnDefinition = { 
/**
 * Column name
 */
name: string; 
/**
 * Column data type
 */
data_type: string; 
/**
 * Whether the column can be null
 */
nullable: boolean; 
/**
 * Whether the column is a primary key
 */
primary_key: boolean; 
/**
 * Default value for the column
 */
default_value: string | null }

/**
 * Column information with detailed metadata for UI display
 */
export type ColumnInfo = { 
/**
 * Column name
 */
name: string; 
/**
 * Database-specific data type string
 */
data_type: string; 
/**
 * Standardized column type category for UI
 */
type_category: ColumnTypeCategory; 
/**
 * Whether the column can be null
 */
nullable: boolean; 
/**
 * Whether the column is a primary key
 */
primary_key: boolean; 
/**
 * Whether the column auto-increments
 */
auto_increment: boolean; 
/**
 * Whether the column is indexed
 */
indexed: boolean; 
/**
 * Whether the column has a unique constraint
 */
unique: boolean; 
/**
 * Character maximum length for text types
 */
char_max_length: number | null; 
/**
 * Numeric precision for numeric types
 */
numeric_precision: number | null; 
/**
 * Numeric scale for numeric types
 */
numeric_scale: number | null; 
/**
 * Default value for the column
 */
default_value: string | null; 
/**
 * Column comment/description
 */
comment: string | null; 
/**
 * Column position in the table
 */
position: number | null; 
/**
 * Column foreign key relationship
 */
foreign_key: ForeignKeyReference | null; 
/**
 * UI display format hint
 */
display_hint: string | null }

/**
 * Database column data type category for UI display
 */
export type ColumnTypeCategory = "Text" | "Numeric" | "Boolean" | "Date" | "DateTime" | "Time" | "Binary" | "Json" | "Array" | "Enum" | "Geometry" | "Network" | "UUID" | "Other"

/**
 * Database constraint
 */
export type ConstraintInfo = { 
/**
 * Constraint name
 */
name: string; 
/**
 * Constraint type
 */
constraint_type: ConstraintType; 
/**
 * Table name
 */
table_name: string; 
/**
 * Schema name
 */
schema_name: string; 
/**
 * Column names involved in the constraint
 */
column_names: string[]; 
/**
 * Foreign key reference (only for foreign keys)
 */
foreign_key_reference: ForeignKeyReference | null; 
/**
 * Check constraint definition (only for check constraints)
 */
check_definition: string | null }

/**
 * Constraint type
 */
export type ConstraintType = "PrimaryKey" | "ForeignKey" | "Unique" | "Check" | "Exclusion"

/**
 * Foreign key reference
 */
export type ForeignKeyReference = { 
/**
 * Referenced schema
 */
referenced_schema: string; 
/**
 * Referenced table
 */
referenced_table: string; 
/**
 * Referenced column
 */
referenced_column: string; 
/**
 * On update action
 */
on_update: string | null; 
/**
 * On delete action
 */
on_delete: string | null }

/**
 * Function information
 */
export type FunctionInfo = { 
/**
 * Function name
 */
name: string; 
/**
 * Schema name
 */
schema: string; 
/**
 * Function arguments
 */
arguments: string[]; 
/**
 * Function return type
 */
return_type: string | null; 
/**
 * Function definition
 */
definition: string | null }

/**
 * Index information
 */
export type IndexInfo = { 
/**
 * Index name
 */
name: string; 
/**
 * Schema name
 */
schema: string; 
/**
 * Table name
 */
table: string; 
/**
 * Is it a unique index
 */
is_unique: boolean; 
/**
 * Is it a primary key index
 */
is_primary: boolean; 
/**
 * Column names in the index
 */
column_names: string[]; 
/**
 * Index method (btree, hash, etc.)
 */
method: string | null }

/**
 * Database query result
 */
export type QueryResult = { 
/**
 * Execution timestamp
 */
timestamp: string; 
/**
 * Query that was executed
 */
query: string; 
/**
 * Rows affected (for DML statements)
 */
rows_affected: string | null; 
/**
 * Execution time in milliseconds
 */
execution_time_ms: string; 
/**
 * Column definitions
 */
columns: ColumnDefinition[]; 
/**
 * Result rows (for SELECT statements)
 */
rows: Row[]; 
/**
 * Any warning messages
 */
warnings: string[]; 
/**
 * Sequential result number when multiple statements are executed
 */
result_index: string }

/**
 * A single row in a query result
 */
export type Row = { 
/**
 * Values indexed by column name
 */
values: Partial<{ [key in string]: string }> }

/**
 * Schema information with detailed metadata
 */
export type SchemaInfo = { 
/**
 * Schema name
 */
name: string; 
/**
 * Tables in this schema
 */
tables: TableInfo[]; 
/**
 * Views in this schema
 */
views: ViewInfo[]; 
/**
 * Functions in this schema
 */
functions: FunctionInfo[]; 
/**
 * Schema constraints
 */
constraints: ConstraintInfo[] }

/**
 * Table information with detailed metadata
 */
export type TableInfo = { 
/**
 * Table name
 */
name: string; 
/**
 * Schema name
 */
schema: string; 
/**
 * Table columns
 */
columns: ColumnInfo[]; 
/**
 * Table constraints
 */
constraints: ConstraintInfo[]; 
/**
 * Table indices
 */
indices: IndexInfo[]; 
/**
 * Primary key column names
 */
primary_key_columns: string[]; 
/**
 * Table row count estimate
 */
row_count_estimate: string | null; 
/**
 * Table size estimate in bytes
 */
size_bytes: string | null; 
/**
 * Table comment/description
 */
comment: string | null; 
/**
 * Last modified timestamp
 */
last_modified: string | null }

/**
 * View information
 */
export type ViewInfo = { 
/**
 * View name
 */
name: string; 
/**
 * Schema name
 */
schema: string; 
/**
 * View columns
 */
columns: ColumnInfo[]; 
/**
 * View definition
 */
definition: string | null }

const ARGS_MAP = { 'db':'{"is_connected":[],"disconnect":[],"connect":[],"get_tables":[],"execute_query":["query"],"get_schema_info":[]}' }
export type Router = { 'db': { is_connected: () => Promise<boolean>, 
connect: () => Promise<null>, 
disconnect: () => Promise<null>, 
execute_query: (query: string) => Promise<QueryResult>, 
get_schema_info: () => Promise<SchemaInfo>, 
get_tables: () => Promise<TableInfo[]> } };


export type { InferCommandOutput }
export const createTauRPCProxy = () => createProxy<Router>(ARGS_MAP)
